<!--
    js
    인터프리터 언어
    memory Heap:
    Call Stack:

    web apis
    1. DOM:
    2. AJAX:
    3. Timeout
    
    동기:
    비동기:

    -----------------------------------------

    defer:

    -----------------------------------------

    식별자: 사용자가 임의로 만드는 명칭 ex) 변수명
    예약어: 자바스크립트 자체적으로 특정 기능을 실행하기 위해 예약된 명령어 ex) const
    실행문: 특정 명령어를 실행하기 위한 구문

    식별자를 작성할 때는 예약어는 피해야 됨.

    -----------------------------------------

    변수
    특정 데이터 값을 임시로 저장하는 공간
    
    쓰는 이유
    1. 특정값을 자주 사용해야 할 때 (성능상의 이점)
    -- 한 번 찾은 내용을 재사용할 수 있기 때문

    2. 반복적인 구문이나 값 등이 여러 코드에 걸쳐서 많이 쓰일 때 (편의상의 이점)

    변수 선언 방식
    var ES5
    let, const ES6
    ECMA Script ES5 < 2015 < ES6

    let: 변경될 수 있는 값을 저장할 때
    const: 변경되는 않는 값을 저장할 때

    let num; // 변수 선언, 값이 저장될 메모리 공간을 생성
    num = 3; // 변수에 값 할당, 변수 공간에 값을 저장
    let num = 3; // 변수 초기화, 변수를 선언하자마자 값을 할당

    변수 작명 유의점
    1. 숫자로 시작 불가
    2. 특수문자 삽입 불가 (_, $는 가능)
    3. - 사용불가
    4. 예약어 사용 불가 (let, const, var 등)
    5. 한글 사용 불가
    6. 자바스크립트는 대소문자 구분

    -----------------------------------------
    
    연산자: 특정값을 도출하기 위해 연산을 처리하는 식별자

    산술연산자: 수학적인 연산 (+, -, /, *, %, ++, --)
    대입연산자: 특정값을 대입하기 위한 연산 (=, +=, -=, *=, /=)
    비교연산자: 두 개 이상의 값을 서로 비교하기 위한 연산 (결과값을 변환, true, false)

    num++: 후위연산자: 초기 변수값을 먼저 연산하고 그 다음에 값을 증가
    ++num: 전위연산자: 초기 변수값을 증가시킨 다음 연산

    ==: 값만 비교
    ===: 값과 자료형까지 비교

    -----------------------------------------

    자료형 (Data Type)
    원시형 자료 (primitive Type) : 특정 값이 메모리에 바로 저장, 값만 저장
    1. 문자(string)
    2. 숫자(number)
    3. 논리형(boolean: true, false)
    4. undefined: 변수를 선언하고 값을 할당하지 않으면 undefined가 대신 저장 (에러 상황)

    참조형 자료 (reference type): 값이 위치하고 있는 참조 주소값만 메모리에 저장 (관련 내장함수까지 같이 참조)
    1. null (object): 명시적으로 (일부로) 특정 변수의 값을 비워둘 때
    2. array (object): 연관된 값들을 그룹으로 묶어서 관리하는 자료형태
    3. object (object): 데이터를 key라는 인덱싱을 통해 자료를 구조적으로 묶어놓은 형태 
    
    -----------------------------------------

    형변환: 특정 조건이 부합되면 자료형이 강제로 변환되는 현상

    let num1 = "2" // 문자
    let num2 = 3 // 숫자
    let num3 = 5 // 숫자
    num1 + num2 + num3 = 235 // 문자
    num3 + num2 + num1 = 82 // 문자

    -----------------------------------------

    배열 : array
    연관된 값들을 하나의 그룹으로 묶어서 나열한 자료구조

    const 변수명 = ["1번째", "2번째, "3번쩨",...]
    colors[n]
    colors[n] = "수정할 값"

    -----------------------------------------

    객체 object
    데이터를 property라는 인덱싱을 통해 구조적으로 묶어놓은 형태

    let student = {
        name : "홍길동",
        age : 28,
        gender : male,
        address : "seoul"
    }

    student.name // 홍길동
    student['name'] // 홍길동
    student.address = "Busan"

    -----------------------------------------

    자료형 검사

    typeof 변수명

    -----------------------------------------

    반복문

    const colors = ["red", "green", "blue"]
    for(let i = 0; i < colors.length; i++){
        console.log(colors[i])
    }

    const classA = [
        {
            name: "Andy",
            age: 20,
            address: "seoul"
        },
        {
            name: "Emma",
            age: 30,
            address: "seoul"
        }
    ]
        for(let num = 0; num < classA.length; num++){
            console.log(classA[num].name)
        }
    
    -----------------------------------------

    for of 반복문
    const colors = ["red", "green", "blue"]

    for(let color of colors){
        console.log(color);
    }

    -----------------------------------------

    for in 반복문

    const student1 = {
        name: "david",
        age: 20,
        hobby: "sport"
    }

    for(let key in student1){
        console.log(student1); // name age hobby
        console.log(student1[key]); // david 20 sport
    }

    -----------------------------------------

    while

    const cars = ["BMW", "VOLVO", "HYUNDAI"]

    for(let i = 0; i < cars.length; i++){
        console.log(cars[i])
    }

    let i = 0;
    while(cars[i]){
        console.log(cars[i]);
        i++
    }

    while문을 사용하기 보다는 for문을 사용하는 것이 더 효울적이기 때문에 사용 빈도가 적다

    -----------------------------------------

    이터러블 객체

    const txt = "HELLO"

    for(let letter of txt){
        console.log(letter); H,E,L,L,O
    }

    -----------------------------------------

    함수(function)
    -- 자주쓰는 실행코드들을 블록단위로 묶어서 패키징 해놓은 형태
    -- 자주쓰는 코드들을 기능단위로 재사용하기 위함
    -- 함수정의: 미리 function 키워드를 이용해서 자주 쓸 코드들을 묶어서 정의하는 행위
    -- 함수호출: 정의되어 있는 함수를 호출해야 지만 비로서 기능이 실행됨

    함수의 종류
    선언적함수
    -- 함수에 미리 이름을 붙여서 정의해놓은 형태
    -- 자바스크립트 파일을 읽을 때 선언적함수를 우선적으로 읽어줌
    -- 선언적 함수는 호출위치가 자유로움(호이스팅)

    function plus(){
        const num1 = 2;
        const num2 = 3;
        console.log(num1+num2);
    }

    plus();
    
    익명함수
    -- 함수에 이름이 없이 정의하는 형태
    -- 익명함수 자체만으로는 호출이 불가능
    -- 변수에 익명함수를 대입하거나 (대입형) 특정 이벤트 객체에 대입하는 식으로 호출가능
    -- 호이스팅 안됨

    const minus = function(){
        const num1 = 2;
        const num2 = 3;
        console.log(num1-num2);
    }

    minus();

    대입형함수
    -- 변수에 익명함수가 대입된 형태
    
    즉시실행함수
    -- 함수가 자기자신을 정의하자마자 바로 자신을 호출
    -- 즉시실행함수를 쓰는 이유: 즉시 실행 함수 안쪽의 값들을 캡슐화

    (function(){
        const num1 = 2;
        const num2 = 3;
        console.log(num1+num2);
    })()

    -----------------------------------------

    함수 매개변수 (parameter)
    - 함수외부에서 함수 내부로 특정값을 전달하기 위한 통로 이름

    인수 (argument)
    - 함수를 호출 때 파라미터를 통해 전달되는 값

    반환값 (return)
    - 함수 내부에서 만들어진 값을 함수 호출 시 외부로 반환
    - 함수 구문 실행도중 특정시점에서 강제로 코드를 실행 중단 될 때

    function plus(num1. num2){
        const = num1 + num2;
        return const;

    }

    plus(2, 3);

    const total = plus(2, 3); // return 전: undefinded, return 후: 5

    -----------------------------------------

    화살표 함수
    -- 기존의 익명함수를 좀 더 쓰기 편하게 축약한 형태
    -- 내부로 전달되는 파라미터가 하나면 괄호는 생략 가능
    -- 코드블록안에서 실행되는 코드가 한 줄이면 코드 블록 괄호도 생략 가능

    const plus = (num1, num2) => {
        const = num1 + num2;
        return const;
    } 

    const plus = num1 => console.log(num1);

    -----------------------------------------

    조건문 (if문)
    -- 특정 조건을 걸어서 해당 조건의 참, 거짓 유무에 따라 코드의 분기를 생성

    if(조건식1){
        조건식1이 참이면 해당코드 블록을 실행,
        거짓이면 해당 코드 블록을 무시하고 다음 조건식으로 넘어감
    }
    else if(조건식2){
        조건식2이 참이면 해당코드 블록을 실행,
        거짓이면 해당 코드 블록을 무시하고 다음 조건식으로 넘어감
    }
    else{
        위에 모든 조건식이 거짓이면 이곳의 코드를 실행하고 종료
    }

    function plus(num1, num2){
        if(num1 === undefined || num2 === undefined){
            console.error("두개의 인수값을 모두 넣어주세요")
        }
        if(typeof num1 !== "number" || typeof num2 !== "number"){
            console.error("두개의 인수값을 모두 숫자로 넣어주세요")
        }

        const result = num1 + num2;
        console.log(result);

    }

    -----------------------------------------

    조건문 switch: 여러개의 코드블록중에서 하나를 선택해야 될 때 사용

    switch(표현식){
        case A:
            //실행할 코드 블록
            break;
        case B:
            //실행할 코드 블록
            break;
        default:
            //실행할 코드 블록
    }

    switch(new Date().getDay()){
        case 0:
            console.log("일요일입니다.")
            break;
        case 1:
            console.log("월요일입니다.")
            break;
        case 2:
            console.log("회요일입니다.")
            break;
        case 3:
            console.log("수요일입니다.")
            break;
        case 4:
            console.log("목요일입니다.")
            break;
        case 5:
            console.log("금요일입니다.")
            break;
        case 6:
            console.log("토요일입니다.")
            break;

    }

    -----------------------------------------

    템플릿 리터럴

    const name = "홍길동"
    const age = 20;

    console.log("안녕하세요. 제 이름은" + name + "이고 나이는" + age + "살입니다.")
    console.log(`안녕하세요. 제 이름은 ${name}이고 나이는 ${age}입니다.`)

    -----------------------------------------

    배열전용 반복문 foreach, map

    콜백함수
    -- 함수 호출 시 인수로 함수가 들어가는 형태

    const color = ["red", "blue"];

    //ES5
    //반복처리 기능, 유사배열(DOM반복 가능)
    color.forEach((반복대상, 인덱스, 배열자신)=>{
    });

    //ES6
    //반복기능외에 추가로 반복도는 배열을 새로운 배열로 복사
    //DOM반복 불가능
    color.map((반복대상, 인덱스, 배열자신)=>{
    })


 -->