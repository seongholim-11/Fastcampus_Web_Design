 <!-- 
    js
    인터프리터 언어
    memory Heap:
    Call Stack:

    web apis
    1. DOM:
    2. AJAX:
    3. Timeout
    
    동기:
    비동기:

    -----------------------------------------

    defer:

    -----------------------------------------

    식별자: 사용자가 임의로 만드는 명칭 ex) 변수명
    예약어: 자바스크립트 자체적으로 특정 기능을 실행하기 위해 예약된 명령어 ex) const
    실행문: 특정 명령어를 실행하기 위한 구문

    식별자를 작성할 때는 예약어는 피해야 됨.

    -----------------------------------------

    변수
    특정 데이터 값을 임시로 저장하는 공간
    
    쓰는 이유
    1. 특정값을 자주 사용해야 할 때 (성능상의 이점)
    -- 한 번 찾은 내용을 재사용할 수 있기 때문

    2. 반복적인 구문이나 값 등이 여러 코드에 걸쳐서 많이 쓰일 때 (편의상의 이점)

    변수 선언 방식
    var ES5
    let, const ES6
    ECMA Script ES5 < 2015 < ES6

    let: 변경될 수 있는 값을 저장할 때
    const: 변경되는 않는 값을 저장할 때

    let num; // 변수 선언, 값이 저장될 메모리 공간을 생성
    num = 3; // 변수에 값 할당, 변수 공간에 값을 저장
    let num = 3; // 변수 초기화, 변수를 선언하자마자 값을 할당

    변수 작명 유의점
    1. 숫자로 시작 불가
    2. 특수문자 삽입 불가 (_, $는 가능)
    3. - 사용불가
    4. 예약어 사용 불가 (let, const, var 등)
    5. 한글 사용 불가
    6. 자바스크립트는 대소문자 구분

    -----------------------------------------
    
    연산자: 특정값을 도출하기 위해 연산을 처리하는 식별자

    산술연산자: 수학적인 연산 (+, -, /, *, %, ++, --)
    대입연산자: 특정값을 대입하기 위한 연산 (=, +=, -=, *=, /=)
    비교연산자: 두 개 이상의 값을 서로 비교하기 위한 연산 (결과값을 변환, true, false)

    num++: 후위연산자: 초기 변수값을 먼저 연산하고 그 다음에 값을 증가
    ++num: 전위연산자: 초기 변수값을 증가시킨 다음 연산

    ==: 값만 비교
    ===: 값과 자료형까지 비교

    -----------------------------------------

    자료형 (Data Type)
    원시형 자료 (primitive Type) : 특정 값이 메모리에 바로 저장, 값만 저장
    1. 문자(string)
    2. 숫자(number)
    3. 논리형(boolean: true, false)
    4. undefined: 변수를 선언하고 값을 할당하지 않으면 undefined가 대신 저장 (에러 상황)

    참조형 자료 (reference type): 값이 위치하고 있는 참조 주소값만 메모리에 저장 (관련 내장함수까지 같이 참조)
    1. null (object): 명시적으로 (일부로) 특정 변수의 값을 비워둘 때
    2. array (object): 연관된 값들을 그룹으로 묶어서 관리하는 자료형태
    3. object (object): 데이터를 key라는 인덱싱을 통해 자료를 구조적으로 묶어놓은 형태 
    
    -----------------------------------------

    형변환: 특정 조건이 부합되면 자료형이 강제로 변환되는 현상

    let num1 = "2" // 문자
    let num2 = 3 // 숫자
    let num3 = 5 // 숫자
    num1 + num2 + num3 = 235 // 문자
    num3 + num2 + num1 = 82 // 문자

    -----------------------------------------

    배열 : array
    연관된 값들을 하나의 그룹으로 묶어서 나열한 자료구조

    const 변수명 = ["1번째", "2번째, "3번쩨",...]
    colors[n]
    colors[n] = "수정할 값"

    -----------------------------------------

    객체 object
    데이터를 property라는 인덱싱을 통해 구조적으로 묶어놓은 형태

    let student = {
        name : "홍길동",
        age : 28,
        gender : male,
        address : "seoul"
    }

    student.name // 홍길동
    student['name'] // 홍길동
    student.address = "Busan"

    -----------------------------------------

    자료형 검사

    typeof 변수명

    -----------------------------------------

    반복문

    const colors = ["red", "green", "blue"]
    for(let i = 0; i < colors.length; i++){
        console.log(colors[i])
    }

    const classA = [
        {
            name: "Andy",
            age: 20,
            address: "seoul"
        },
        {
            name: "Emma",
            age: 30,
            address: "seoul"
        }
    ]
        for(let num = 0; num < classA.length; num++){
            console.log(classA[num].name)
        }
    
    -----------------------------------------

    for of 반복문
    const colors = ["red", "green", "blue"]

    for(let color of colors){
        console.log(color);
    }

    -----------------------------------------

    for in 반복문

    const student1 = {
        name: "david",
        age: 20,
        hobby: "sport"
    }

    for(let key in student1){
        console.log(student1); // name age hobby
        console.log(student1[key]); // david 20 sport
    }

    -----------------------------------------

    while

    const cars = ["BMW", "VOLVO", "HYUNDAI"]

    for(let i = 0; i < cars.length; i++){
        console.log(cars[i])
    }

    let i = 0;
    while(cars[i]){
        console.log(cars[i]);
        i++
    }

    while문을 사용하기 보다는 for문을 사용하는 것이 더 효울적이기 때문에 사용 빈도가 적다

    -----------------------------------------

    이터러블 객체

    const txt = "HELLO"

    for(let letter of txt){
        console.log(letter); H,E,L,L,O
    }

    -----------------------------------------

    함수(function)
    -- 자주쓰는 실행코드들을 블록단위로 묶어서 패키징 해놓은 형태
    -- 자주쓰는 코드들을 기능단위로 재사용하기 위함
    -- 함수정의: 미리 function 키워드를 이용해서 자주 쓸 코드들을 묶어서 정의하는 행위
    -- 함수호출: 정의되어 있는 함수를 호출해야 지만 비로서 기능이 실행됨

    함수의 종류
    선언적함수
    -- 함수에 미리 이름을 붙여서 정의해놓은 형태
    -- 자바스크립트 파일을 읽을 때 선언적함수를 우선적으로 읽어줌
    -- 선언적 함수는 호출위치가 자유로움(호이스팅)

    function plus(){
        const num1 = 2;
        const num2 = 3;
        console.log(num1+num2);
    }

    plus();
    
    익명함수
    -- 함수에 이름이 없이 정의하는 형태
    -- 익명함수 자체만으로는 호출이 불가능
    -- 변수에 익명함수를 대입하거나 (대입형) 특정 이벤트 객체에 대입하는 식으로 호출가능
    -- 호이스팅 안됨

    const minus = function(){
        const num1 = 2;
        const num2 = 3;
        console.log(num1-num2);
    }

    minus();

    대입형함수
    -- 변수에 익명함수가 대입된 형태
    
    즉시실행함수
    -- 함수가 자기자신을 정의하자마자 바로 자신을 호출
    -- 즉시실행함수를 쓰는 이유: 즉시 실행 함수 안쪽의 값들을 캡슐화

    (function(){
        const num1 = 2;
        const num2 = 3;
        console.log(num1+num2);
    })()

    -----------------------------------------

    함수 매개변수 (parameter)
    - 함수외부에서 함수 내부로 특정값을 전달하기 위한 통로 이름

    인수 (argument)
    - 함수를 호출 때 파라미터를 통해 전달되는 값

    반환값 (return)
    - 함수 내부에서 만들어진 값을 함수 호출 시 외부로 반환
    - 함수 구문 실행도중 특정시점에서 강제로 코드를 실행 중단 될 때

    function plus(num1. num2){
        const = num1 + num2;
        return const;

    }

    plus(2, 3);

    const total = plus(2, 3); // return 전: undefinded, return 후: 5

    -----------------------------------------

    화살표 함수
    -- 기존의 익명함수를 좀 더 쓰기 편하게 축약한 형태
    -- 내부로 전달되는 파라미터가 하나면 괄호는 생략 가능
    -- 코드블록안에서 실행되는 코드가 한 줄이면 코드 블록 괄호도 생략 가능

    const plus = (num1, num2) => {
        const = num1 + num2;
        return const;
    } 

    const plus = num1 => console.log(num1);

    -----------------------------------------

    조건문 (if문)
    -- 특정 조건을 걸어서 해당 조건의 참, 거짓 유무에 따라 코드의 분기를 생성

    if(조건식1){
        조건식1이 참이면 해당코드 블록을 실행,
        거짓이면 해당 코드 블록을 무시하고 다음 조건식으로 넘어감
    }
    else if(조건식2){
        조건식2이 참이면 해당코드 블록을 실행,
        거짓이면 해당 코드 블록을 무시하고 다음 조건식으로 넘어감
    }
    else{
        위에 모든 조건식이 거짓이면 이곳의 코드를 실행하고 종료
    }

    function plus(num1, num2){
        if(num1 === undefined || num2 === undefined){
            console.error("두개의 인수값을 모두 넣어주세요")
        }
        if(typeof num1 !== "number" || typeof num2 !== "number"){
            console.error("두개의 인수값을 모두 숫자로 넣어주세요")
        }

        const result = num1 + num2;
        console.log(result);

    }

    -----------------------------------------

    조건문 switch: 여러개의 코드블록중에서 하나를 선택해야 될 때 사용

    switch(표현식){
        case A:
            //실행할 코드 블록
            break;
        case B:
            //실행할 코드 블록
            break;
        default:
            //실행할 코드 블록
    }

    switch(new Date().getDay()){
        case 0:
            console.log("일요일입니다.")
            break;
        case 1:
            console.log("월요일입니다.")
            break;
        case 2:
            console.log("회요일입니다.")
            break;
        case 3:
            console.log("수요일입니다.")
            break;
        case 4:
            console.log("목요일입니다.")
            break;
        case 5:
            console.log("금요일입니다.")
            break;
        case 6:
            console.log("토요일입니다.")
            break;

    }

    -----------------------------------------

    템플릿 리터럴

    const name = "홍길동"
    const age = 20;

    console.log("안녕하세요. 제 이름은" + name + "이고 나이는" + age + "살입니다.")
    console.log(`안녕하세요. 제 이름은 ${name}이고 나이는 ${age}입니다.`)

    -----------------------------------------

    배열전용 반복문 foreach, map

    콜백함수
    -- 함수 호출 시 인수로 함수가 들어가는 형태

    const color = ["red", "blue"];

    //ES5
    //반복처리 기능, 유사배열(DOM반복 가능)
    color.forEach((반복대상, 인덱스, 배열자신)=>{
    });

    //ES6
    //반복기능외에 추가로 반복도는 배열을 새로운 배열로 복사
    //DOM반복 불가능
    color.map((반복대상, 인덱스, 배열자신)=>{
    })


    -----------------------------------------

    문자열 내장함수

    문자열.length : 문자열의 길이를 반환
    문자열.indexOf() : 찾고자 하는 문자열의 위치 반환
    문자열.slice() : 문자열에서 특정 부분을 추출해서 새로운 문자열로 반환
    문자열.substr() : 문자열에서 특정 부분을 잘라냄
    문자열.replace(): 문자열에서 특정 문자값을 바꿔치기
    문자열.split(): 문자열을 배열로 변환

    const txt = "Hello World"


    console.log(txt.length) // 11 // 띄어쓰기도 포함

    console.log(txt.indexOf("apple")) // 없으면 -1 있으면 위치값(몇번째) // 해당 문자열을 가지고 있는지 없는지로도 활용

    const txt2 = txt.slice(0, 5) // Hello

    const txt3 = txt.substr(6, 3) // Wor // 긴 글 중 n글자만 남겨두고 ... 붙이기
    const text = "떴다 떴다 비행기 날아라 날아라 높이높이 날아라 우리 비행기 내가 만든 비행기 날아라 날아라 멀리멀리 날아라 우리 비행기"
    let result = "";

    if(text.length > 15){
        result = text.substr(0, 15) + "...";
    }else{
        result = text
    }

    // 삼항연산자
    (text.length > 15) ? result = text.substr(0, 15) + "..." : result = text;

    let shark = "아기 상어 뚜 루루 뚜루 귀여운 뚜 루루 뚜루 바닷속 뚜 루루 뚜루 아기 상어"
    // 대소문자 구분
    shark.replace("상어", "고래") // 맨처음 나오는 상어만 고래로 변경
    shark.replace(/상어/g, "고래") // 모든 상어를 고래로 변경
    shark.replace(/상어/ig, "고래") // 모든 상어를 고래로 변경 // 대소문자 구분하지 않음

    const colors = "red, green, blue"
    const arr = colors.split(",") // ","를 기준으로 배열 생성

    -----------------------------------------

    parseInt(변환할 값) : 해당값을 정수로 변환
    parseFloat(변환할 값) : 해당값을 실수로 변환

    const num = "5.3";
    parseInt(num); // 5 // 무조건 버림
    parseFloat(num); // 5.3

    -----------------------------------------

    배열 내장함수1

    toString(): 배열을 문자로 변환
    join() : 구분자를 활용해 문자열로 이어붙이기
    pop() : 배열의 마지막요소 제거(리턴값으로 잘라낸 요소 반환)
    push() : 배열의 끝부분에 새로운 요소 추가(리턴값으로 배열의 길이 반환)
    shift() : 배열의 첫 부분 요소 제거 (리턴값으로 잘라낸 요소 반환)
    unshift() : 배열의 첫 부분에 새로운 요소 추가(리턴값으로 길이 반환)
    splice(삽입위치, 잘라낼 갯수, 추가할 내용) : 배열에 새로운 요소를 잘라서 붙임
    concat() : 두개의 배열 합치기 (새로운 배열을 리턴값)
    slice(n) : 배열 잘라내기 // 인덱스 n번째부터 잘라내기

    const colors = ["red","green","blue"];

    const result = colors.toString() // red,green,blue

    const result = colors.join(" + ") // red + green + blue

    colors.pop() // "blue"
    colors // ["red","green"];

    colors.push("aqua") // 3
    colors // ["red", "green", "aqua"];

    colors.shift() // "red"
    colors // ["green", "aqua"];

    colors.unshift("pink") // 3
    colors // ["pink", "green", "aqua"];

    colors.splice(1, 0, "red")
    colors // ["pink", "red", "green", "aqua"];

    const fruit = ["apple", "orange"]
    colors.concat(fruit) // ["pink", "red", "green", "aqua", "apple", "orange"]; // 여러 개의 배열 추가 가능

    colors.slice(1) // ["red", "green", "aqua"];

    -----------------------------------------

    배열 내장함수2

    sort() : 알파벳순으로 요소 정렬
    reverse() : 역순으로 요소 정렬
    sort((a, b) => {return a-b}) : 올림차순으로 정렬 // 리턴값이 음수이면 b가 더 크다는 의미, 뒤으로 배치
    sort((a, b) => {return b-a}) : 내림차순으로 정렬 // 리턴값이 음수이면 b가 더 작다는 의미, 뒤으로 배치
    sort((a, b) => {return a-b})[0] : 최소값 반환
    sort((a, b) => {return b-a})[0] : 최대값 반환

    const names = ["David", "Andy", "Tom", "Michel"]
    sort(names) // ["Andy", "David", "Michel", "Tom"]
    reverse(names) // ["Tom", "Michel", "David", "Andy"]

    const nums = [5, 8, 1, 6, 9];
    nums.sort((a, b) => {return a-b}) // [1, 5, 6, 8, 9]
    nums.sort((a, b) => {return b-a}) // [9, 8, 6, 5, 1]
    nums.sort((a, b) => {return a-b})[0] // 1
    nums.sort((a, b) => {return b-a})[0] // 9

    -----------------------------------------

    Date 날짜 관련 객체

    new Date() : 날짜 정보값 반환
    new Date().getTime() : 1970년 1월 1일 이후부터의 밀리세컨드 단위 숫자 반환
    new Date().getFullYear() : 해당 년도를 반환

    new Date().getMonth() : 해당 월을 반환 // 1월부터 0으로 반환
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Oct', 'Nov', 'Dec', 'Sep']
    console.log(months[new Date().getMonth()])

    new Date().getDate() : 해당 일을 반환
    new Date().getHours() : 현재 시간을 반환 // 24시간 단위
    new Date().getMinutes() : 현재 분을 반환
    new Date().getSeconds() : 현재 초를 반환

    -----------------------------------------

    Math 숫자 관련 객체

    Math.around(x) : x값에서 제일 근접한 정수를 반환
    Math.around(2.3) // 2

    Math.pow(x, y) : x의 값을 y의 횟수만큼 제곱한 값을 반환
    Math.pow(3, 2) // 9

    Math.sqrt(x) : x의 제곱근 값을 반환
    Math.sqrt(4) // 2

    Math.abs(x) : x의 양수값을 반환
    Math.abs(-2.3) // 2.3

    Math.ceil(x) : x값에서 소수점 아래 값을 무조건 올림해서 정수 반환
    Math.ceil(2.4) // 3 

    Math.floor(x) : x값에서 소수점 아래 값을 무조건 버린 정수 반환
    Math.floor(2.488) // 2

    Math.min() : 인수로 넣은 값들 중에서 제일 작은 값을 반환
    Math.min(1, 2, 3, 4, 5) // 1

    Math.max() : 인수로 넣은 값들 중에서 제일 큰 값을 반환
    Math.max(1, 2, 3, 4, 5, 6) // 6

    Math.random(): 0에서 1사이의 실수를 랜덤으로 반환
    Math.floor(Math.random() * num) : 특정 수까지의 랜덤한 정수를 반환
    Math.floor(Math.random() * num) // 0 ~ n까지 숫자를 출력하고 싶으면 num = n + 1


    -----------------------------------------

    비구조화 할당 (구조분해 할당)

    const fruit = ['apple', 'orange', 'melon'];

    const [fruit1, fruit2, fruit3] = fruit;

    const studentA = {
        name: "David",
        age: 20,
        isFemale : false,
        hobby : "reading"
    }

    const {name, age, isFemale, hobby} = studentA

    -----------------------------------------

    전개 연산자

    let arr = ["red", "green", "blue"]
    let arr2 = [...arr, "pink"] // ...arr : 배열을 복사해서 가져옴
    let arr3 = [...arr, ...arr2] // 배열 합치기

    let defaults = {
        color : "gray",
        hobby : "nap",
        address : "nowhere"
    }

    let customs = {
        color : "hotpink",
        hobby : "nap",
        address : "seoul"
    }

    // JavaScript에서 객체의 속성은 일반적으로 고유한 이름을 가져야 합니다. 즉, 동일한 이름의 속성을 가진 객체는 생성할 수 없습니다. 객체의 속성은 유일해야 하며, 중복된 속성 이름이 있다면 최근에 정의된 속성이 이전에 정의된 속성을 덮어씁니다.
    let newObj = {...defaults, ...customs} // 덮어쓰기 됨

    dom 제어

    DOM(Document Object Model) 문서 객체 모델
    // DOM은 브라우저 역할 

    defer란?

    자식요소 탐색: 부모요소.querySelector(), 부모요소.children
    형제요소 탐색: 이전 형제요소 탐색: 형제요소.previousElementSibling
    형제요소 탐색: 다음 형제요소 탐색: 형제요소.nextElementSibling

    부모요소 탐색
    : 현재요소.parentElement; // 직계 부모
    : 현재요소.closest(); // 조상 
    
    <html>
        <body>
            <section id="wrap">
                <article class="box1">TEXT1</article>
                <article class="box2"><a href="#">TEXT2</a></article>
                <article class="box3"><a href="#">TEXT3</a></article>
            </section>

            <script>
                const wrap = document.querySelector('#wrap')
                const box2 = wrap.querySelector('.box2')

                const children = wrap.children; // 모든 자식 탐색 // 유사 배열: 배열처럼 보이지만 배열은 아닌 그룹요소 
                
                const prev = box2.previousElementSibling;
                const next = box2.nextElementSibling;

                const a = box2.querySelector("a").parentElement;
                const b = box2.querySelector("a").closest('#wrap');
            </script>
        </body>
    </html>
    -->